---
title: "React-Query Deep Dive 2. ì£¼ìš” í´ë˜ìŠ¤ ì‚´í´ë³´ê¸°"
date: "2025-03-20T21:09:18.164Z"
description: "react-query ë‚´ë¶€ì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ì—¬ëŸ¬ í´ë˜ìŠ¤ë“¤ì„ ì‚´í´ë´…ë‹ˆë‹¤."
category: "ê¸°ìˆ ì•„í‹°í´"
estimation: 15
thumbnail: "./thumbnail.png"
slug: "/react-query-deep-dive-2"
---

ì´ë²ˆ ì•„í‹°í´ì—ì„œëŠ” react-query ë‚´ë¶€ì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ê³µí†µ ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤ì™€ í•µì‹¬ í´ë˜ìŠ¤ì— ëŒ€í•´ì„œ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

## ê³µí†µ ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤

ë‚´ë¶€ì ìœ¼ë¡œ ìì£¼ ì‚¬ìš©ë˜ëŠ” ëª‡ê°€ì§€ ê³µí†µ ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤(Subscribable, Removable, FocusManger, NotifyManager, OnlineManager)ì— ëŒ€í•´ì„œ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

### Subscribable

```typescript
export class Subscribable<TListener extends Function> {
  protected listeners = new Set<TListener>()

  constructor() {
    this.subscribe = this.subscribe.bind(this)
  }

  subscribe(listener: TListener): () => void {
    this.listeners.add(listener)

    this.onSubscribe()

    return () => {
      this.listeners.delete(listener)
      this.onUnsubscribe()
    }
  }

  hasListeners(): boolean {
    return this.listeners.size > 0
  }

  protected onSubscribe(): void {
    // ì•„ë¬´ ë™ì‘ì´ ì •ì˜ë˜ì–´ìˆì§€ ì•ŠìŒ
  }

  protected onUnsubscribe(): void {
    // ì•„ë¬´ ë™ì‘ì´ ì •ì˜ë˜ì–´ìˆì§€ ì•ŠìŒ
  }
}
```

ì´ í´ë˜ìŠ¤ëŠ” ìƒì†ë°›ëŠ” í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ê°€ êµ¬ë…ê°€ëŠ¥í•˜ë„ë¡ í•´ì¤ë‹ˆë‹¤. ë‚´ë¶€ ë©”ì„œë“œì˜ ì¢…ë¥˜ë‚˜ êµ¬í˜„ì€ êµ¬ë…/ë°œí–‰ íŒ¨í„´ì˜ ì¼ë°˜ì ì¸ í˜•íƒœì…ë‹ˆë‹¤.

ì¶”ê°€ì ìœ¼ë¡œ êµ¬ë…ê³¼ í•´ì œì‹œ í˜¸ì¶œë˜ëŠ” `onSubscribe`,`onUnsubscribe`í•¨ìˆ˜ë‚´ë¶€ë¥¼ ë¹ˆìƒíƒœë¡œ ì„ ì–¸í•˜ì—¬ ë‚´ë¶€ë¡œì§ì„ ìì‹í´ë˜ìŠ¤ì—ì„œ ì •ì˜í•˜ë„ë¡ í•´ë‘ì—ˆë‹¤ëŠ” ê²ƒë§Œ ê¸°ì–µí•´ë‘¡ì‹œë‹¤.

### Removable

```typescript
export abstract class Removable {
  gcTime!: number
  #gcTimeout?: ReturnType<typeof setTimeout>

  destroy(): void {
    this.clearGcTimeout()
  }

  protected scheduleGc(): void {
    this.clearGcTimeout()

    if (isValidTimeout(this.gcTime)) {
      this.#gcTimeout = setTimeout(() => {
        this.optionalRemove()
      }, this.gcTime)
    }
  }

  protected updateGcTime(newGcTime: number | undefined): void {
    this.gcTime = Math.max(this.gcTime || 0, newGcTime ?? 5 * 60 * 1000)
  }

  protected clearGcTimeout() {
    if (this.#gcTimeout) {
      clearTimeout(this.#gcTimeout)
      this.#gcTimeout = undefined
    }
  }

  protected abstract optionalRemove(): void
}
```

ì´ í´ë˜ìŠ¤ëŠ” ìƒì†ë°›ëŠ” í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ê°€ ì‹œê°„ì— ë”°ë¼ ì œê±°ë˜ë¡ í•´ì¤ë‹ˆë‹¤. `scheduleGc`í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ ì œê±°ë¥¼ ì˜ˆì•½í•˜ë©´,
ì¤‘ê°„ì— `clearGcTimeout`í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì§€ ì•ŠëŠ”ì´ìƒ íƒ€ì„ì•„ì›ƒ ì‹œê°„ì´ ë˜ì—ˆì„ë•Œ `optionalRemove`í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ ê°ì²´ë¥¼ ì œê±°í•©ë‹ˆë‹¤.

`optionalRemove`í•¨ìˆ˜ì˜ ê²½ìš°`Subscribable`í´ë˜ìŠ¤ì˜ `onSubscribe`,`onUnsubscribe`ë©”ì„œë“œì™€ ìœ ì‚¬í•˜ê²Œ ìì‹ í´ë˜ìŠ¤ì— êµ¬í˜„ì„ ìœ„ì„í•˜ì˜€ëŠ”ë°, ì—¬ê¸°ì„œëŠ” ì¶”ìƒí´ë˜ìŠ¤ì´ë¯€ë¡œ ë°˜ë“œì‹œ êµ¬í˜„í•´ì•¼í•œë‹¤ëŠ” ì°¨ì´ê°€ ìˆìŠµë‹ˆë‹¤.
ì´ìœ ëŠ” `onSubscribe`,`onUnsubscribe`ëŠ” í•µì‹¬ê¸°ëŠ¥ì¸ êµ¬ë…ì„ ìœ„í•œ ë©”ì„œë“œê°€ ì•„ë‹ˆë¼ êµ¬ë…ì´ ë˜ê±°ë‚˜ í•´ì œë˜ì—ˆì„ë•Œ ë°œìƒí•˜ëŠ” ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ì´ë¯€ë¡œ ë‚´ë¶€ êµ¬í˜„ì´ í•„ìš”í•˜ì§€ ì•Šì§€ë§Œ, `optionalRemove`ëŠ” ì‚­ì œë¼ëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ê¸° ìœ„í•´ ë°˜ë“œì‹œ í•„ìš”í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

### FocusManager

```typescript
export class FocusManager extends Subscribable<Listener> {
  #focused?: boolean
  #cleanup?: () => void

  #setup: SetupFn

  constructor() {
    super()
    this.#setup = onFocus => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus()
        window.addEventListener("visibilitychange", listener, false)

        return () => {
          window.removeEventListener("visibilitychange", listener)
        }
      }
      return
    }
  }

  protected onSubscribe(): void {
    if (!this.#cleanup) {
      this.setEventListener(this.#setup)
    }
  }

  protected onUnsubscribe() {
    if (!this.hasListeners()) {
      this.#cleanup?.()
      this.#cleanup = undefined
    }
  }

  setEventListener(setup: SetupFn): void {
    this.#setup = setup
    this.#cleanup?.()
    this.#cleanup = setup(focused => {
      if (typeof focused === "boolean") {
        this.setFocused(focused)
      } else {
        this.onFocus()
      }
    })
  }

  setFocused(focused?: boolean): void {
    const changed = this.#focused !== focused
    if (changed) {
      this.#focused = focused
      this.onFocus()
    }
  }

  onFocus(): void {
    const isFocused = this.isFocused()
    this.listeners.forEach(listener => {
      listener(isFocused)
    })
  }

  isFocused(): boolean {
    if (typeof this.#focused === "boolean") {
      return this.#focused
    }

    return globalThis.document?.visibilityState !== "hidden"
  }
}

export const focusManager = new FocusManager()
```

ì´ í´ë˜ìŠ¤ëŠ” ì‹±ê¸€í†¤ìœ¼ë¡œ ìƒì„±ëœ ì¸ìŠ¤í„´ìŠ¤ë¥¼ êµ¬ë…í•˜ë©´ í˜„ì¬ ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ í¬ì»¤ìŠ¤ ì—¬ë¶€(í™”ë©´ì´ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ë³´ì—¬ì£¼ê³ ìˆëŠ”ì§€ ì—¬ë¶€)ë¥¼ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ í¬ì»¤ìŠ¤ ì—¬ë¶€ë¥¼ í™•ì¸í•˜ê¸° ìœ„í•´ì„œ ë¸Œë¼ìš°ì €ì˜ `visibilitychange`ì´ë²¤íŠ¸ì™€ `visibilityState`ìƒíƒœë¥¼ ì´ìš©í•©ë‹ˆë‹¤.

ì´ í´ë˜ìŠ¤ê°€ ì‹±ê¸€í†¤ì¸ ì´ìœ ëŠ”, í¬ì»¤ìŠ¤ ìƒíƒœê°€ ì• í”Œë¦¬ì¼€ì´ì…˜ ë‚´ì—ì„œ ì—¬ëŸ¬ê°œì¼ìˆ˜ ì—†ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ë”°ë¼ì„œ ì‹±ê¸€í†¤ì„ ìƒì„±í•˜ê³ , ì´ë¥¼ í•„ìš”í•œê³³ì—ì„œ êµ¬ë…í•´ ì‚¬ìš©í•˜ê²Œ ë©ë‹ˆë‹¤. ê°€ì¥ ì¼ë°˜ì ìœ¼ë¡œ ì´ ê°ì²´ê°€ ì‚¬ìš©ë˜ëŠ” ìƒí™©ì€ ì‚¬ìš©ìê°€ ì°½ì„ í¬ì»¤ìŠ¤í–ˆì„ë•Œ staleìƒíƒœì¸ ì¿¼ë¦¬ë¥¼ ë‹¤ì‹œ íŒ¨ì¹˜í•˜ëŠ”ê²ƒì…ë‹ˆë‹¤.

### onlineManager

```typescript
import { Subscribable } from "./subscribable"
import { isServer } from "./utils"

type Listener = (online: boolean) => void
type SetupFn = (setOnline: Listener) => (() => void) | undefined

export class OnlineManager extends Subscribable<Listener> {
  #online = true
  #cleanup?: () => void

  #setup: SetupFn

  constructor() {
    super()
    this.#setup = onOnline => {
      if (!isServer && window.addEventListener) {
        const onlineListener = () => onOnline(true)
        const offlineListener = () => onOnline(false)
        // Listen to online
        window.addEventListener("online", onlineListener, false)
        window.addEventListener("offline", offlineListener, false)

        return () => {
          window.removeEventListener("online", onlineListener)
          window.removeEventListener("offline", offlineListener)
        }
      }

      return
    }
  }

  protected onSubscribe(): void {
    if (!this.#cleanup) {
      this.setEventListener(this.#setup)
    }
  }

  protected onUnsubscribe() {
    if (!this.hasListeners()) {
      this.#cleanup?.()
      this.#cleanup = undefined
    }
  }

  setEventListener(setup: SetupFn): void {
    this.#setup = setup
    this.#cleanup?.()
    this.#cleanup = setup(this.setOnline.bind(this))
  }

  setOnline(online: boolean): void {
    const changed = this.#online !== online

    if (changed) {
      this.#online = online
      this.listeners.forEach(listener => {
        listener(online)
      })
    }
  }

  isOnline(): boolean {
    return this.#online
  }
}

export const onlineManager = new OnlineManager()
```

ì´ í´ë˜ìŠ¤ëŠ” ì‹±ê¸€í†¤ìœ¼ë¡œ ìƒì„±ëœ ì¸ìŠ¤í„´ìŠ¤ë¥¼ êµ¬ë…í•˜ë©´ í˜„ì¬ ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ì˜¨ë¼ì¸ì—¬ë¶€(ë„¤íŠ¸ì›Œí¬ ì—°ê²° ì—¬ë¶€)ë¥¼ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ì˜¨ë¼ì¸ ì—¬ë¶€ë¥¼ í™•ì¸í•˜ê¸° ìœ„í•´ì„œ ë¸Œë¼ìš°ì €ì˜ `online`,`offline`ì´ë²¤íŠ¸ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

ì´ í´ë˜ìŠ¤ê°€ ì‹±ê¸€í†¤ì¸ ì´ìœ ëŠ”, ë„¤íŠ¸ì›Œí¬ì˜ ì—°ê²° ìƒíƒœê°€ ì• í”Œë¦¬ì¼€ì´ì…˜ ë‚´ì—ì„œ ì—¬ëŸ¬ê°œ ì¼ìˆ˜ ì—†ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ë”°ë¼ì„œ ì‹±ê¸€í†¤ì„ ìƒì„±í•˜ê³ , ì´ë¥¼ í•„ìš”í•œê³³ì—ì„œ êµ¬ë…í•´ ì‚¬ìš©í•˜ê²Œ ë©ë‹ˆë‹¤. ê°€ì¥ ì¼ë°˜ì ìœ¼ë¡œ ì´ ê°ì²´ë¥¼ ì‚¬ìš©í•˜ëŠ” ìƒí™©ì€ ì¿¼ë¦¬ íŒ¨ì¹˜ì¤‘ì— ë„¤íŠ¸ì›Œí¬ê°€ ëŠì–´ì¡Œì„ê²½ìš° ë‹¤ì‹œ ë„¤íŠ¸ì›Œí¬ê°€ ì—°ê²°ëœ ì‹œì ì— ë°ì´í„°ë¥¼ ë°›ì•„ì˜¤ëŠ”ê²ƒì…ë‹ˆë‹¤.

### notifyManager

```typescript
export function createNotifyManager() {
  let queue: Array<NotifyCallback> = []
  let transactions = 0
  let notifyFn: NotifyFunction = callback => {
    callback()
  }
  let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {
    callback()
  }
  let scheduleFn: ScheduleFunction = cb => setTimeout(cb, 0)

  const schedule = (callback: NotifyCallback): void => {
    if (transactions) {
      queue.push(callback)
    } else {
      scheduleFn(() => {
        notifyFn(callback)
      })
    }
  }

  const flush = (): void => {
    const originalQueue = queue
    queue = []
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach(callback => {
            notifyFn(callback)
          })
        })
      })
    }
  }

  const batch = <T>(callback: () => T): T => {
    let result
    transactions++
    try {
      result = callback()
    } finally {
      transactions--
      if (!transactions) {
        flush()
      }
    }
    return result
  }

  const batchCalls = <T extends Array<unknown>>(
    callback: BatchCallsCallback<T>
  ): BatchCallsCallback<T> => {
    return (...args) => {
      schedule(() => {
        callback(...args)
      })
    }
  }

  return {
    batch,

    batchCalls,
    schedule,
    setNotifyFunction: (fn: NotifyFunction) => {
      notifyFn = fn
    },
    setBatchNotifyFunction: (fn: BatchNotifyFunction) => {
      batchNotifyFn = fn
    },
    setScheduler: (fn: ScheduleFunction) => {
      scheduleFn = fn
    },
  } as const
}

// SINGLETON
export const notifyManager = createNotifyManager()
```

ì´ í´ë˜ìŠ¤ëŠ” ì‹±ê¸€í†¤ìœ¼ë¡œ ìƒì„±ëœ ì¸ìŠ¤í„´ìŠ¤ì˜ ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ë©´ íŠ¹ì • ì‘ì—…ë“¤ì„ ì¼ê´„ì ìœ¼ë¡œ ìˆ˜í–‰í• ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤.

`schedule`í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ê±°ë‚˜, `schedule`í•¨ìˆ˜ë¡œ ë˜í•‘í•˜ëŠ” `batchCall`í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œ ê²°ê³¼ë¥¼ ì‹¤í–‰í•  ê²½ìš° íŠ¸ëœì­ì…˜ ìƒíƒœê°€ ì•„ë‹ˆë¼ë©´ í•¨ìˆ˜ë¥¼ `setTimeout`ì„ ì´ìš©í•´ ë¹„ë™ê¸°ë¡œ ì‹¤í–‰í•˜ì§€ë§Œ, ê·¸ë ‡ì§€ ì•ŠëŠ”ë‹¤ë©´ íì— ì ì¬í•´ë‘¡ë‹ˆë‹¤. ê·¸ë¦¬ê³  íì— ì ì¬ëœ ì‘ì—…ì€ `batch`í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ì˜€ì„ë•Œ ëª¨ë‘ ì‹¤í–‰ë˜ê²Œë©ë‹ˆë‹¤.

ì´ í´ë˜ìŠ¤ê°€ ì‹±ê¸€í†¤ì¸ ì´ìœ ëŠ”, ëª¨ë“  ë°°ì¹˜ ì‹¤í–‰ì„ í•œêµ°ë°ì„œ ê´€ë¦¬í•˜ê¸° ìœ„í•´ì„œì…ë‹ˆë‹¤. ì´ í´ë˜ìŠ¤ì˜ `schedule`ì´ë‚˜ `batchCall`ë¥¼ ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©í•˜ë©´, í•œë²ˆì˜ ë¦¬ë Œë”ë§ìœ¼ë¡œ êµ¬ë…í•œ queryê°€ ì»´í¬ë„ŒíŠ¸ì— ë°˜ì˜ë ìˆ˜ ìˆë„ë¡ í•´ì¤ë‹ˆë‹¤.

## ì£¼ìš” í´ë˜ìŠ¤

![ì£¼ìš” ìš”ì†Œë“¤ ê°„ì˜ ê´€ê³„](./query-relation.png)

```typescript
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from "@tanstack/react-query"

const queryClient = new QueryClient()

function App() {
  queryClient.setQueryData(["query3"], {})

  return (
    <QueryClientProvider client={queryClient}>
      <Component1 />
      <Component2 />
    </QueryClientProvider>
  )
}

function Component1() {
  const { data: query1Data } = useQuery({
    queryKey: ["query1"],
    queryFn: () =>
      fetch("https://api.github.com/repos/TanStack/query").then(res =>
        res.json()
      ),
  })

  const { data: query2Data } = useQuery({
    queryKey: ["query2"],
    queryFn: () =>
      fetch("https://api.github.com/repos/TanStack/router").then(res =>
        res.json()
      ),
  })

  return (
    <div>
      <div>
        <h1>{query1Data?.name}</h1>
        <p>{query1Data?.description}</p>
        <strong>ğŸ‘€ {query1Data?.subscribers_count}</strong>{" "}
        <strong>âœ¨ {query1Data?.stargazers_count}</strong>{" "}
        <strong>ğŸ´ {query1Data?.forks_count}</strong>
      </div>
      <div>
        <h1>{query2Data?.name}</h1>
        <p>{query2Data?.description}</p>
        <strong>ğŸ‘€ {query2Data?.subscribers_count}</strong>{" "}
        <strong>âœ¨ {query2Data?.stargazers_count}</strong>{" "}
        <strong>ğŸ´ {query2Data?.forks_count}</strong>
      </div>
    </div>
  )
}

function Component2() {
  const { data: query1Data } = useQuery({
    queryKey: ["query1"],
    queryFn: () =>
      fetch("https://api.github.com/repos/TanStack/query").then(res =>
        res.json()
      ),
  })

  const { data: query2Data } = useQuery({
    queryKey: ["query4"],
    queryFn: () =>
      fetch("https://api.github.com/repos/TanStack/virtual").then(res =>
        res.json()
      ),
  })

  return (
    <div>
      <div>
        <h1>{query1Data?.name}</h1>
        <p>{query1Data?.description}</p>
        <strong>ğŸ‘€ {query1Data?.subscribers_count}</strong>{" "}
        <strong>âœ¨ {query1Data?.stargazers_count}</strong>{" "}
        <strong>ğŸ´ {query1Data?.forks_count}</strong>
      </div>
      <div>
        <h1>{query2Data?.name}</h1>
        <p>{query2Data?.description}</p>
        <strong>ğŸ‘€ {query2Data?.subscribers_count}</strong>{" "}
        <strong>âœ¨ {query2Data?.stargazers_count}</strong>{" "}
        <strong>ğŸ´ {query2Data?.forks_count}</strong>
      </div>
    </div>
  )
}
```

ì¿¼ë¦¬ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ ê´€ì—¬í•˜ëŠ” ê°ì²´ëŠ” `queryClient`, `querycache`, `query`, `queryObserver` ì´ ë„¤ê°€ì§€ì…ë‹ˆë‹¤.

ì»´í¬ë„ŒíŠ¸ëŠ” `queryObserver`ë¥¼ êµ¬ë…í•˜ê³  `queryObserver`ëŠ” `query`ë¥¼ êµ¬ë…í•˜ë©° ì´ `query`ë“¤ì€ `queryCache`ì— ì €ì¥ë˜ì–´ ê´€ë¦¬ë©ë‹ˆë‹¤. ë˜í•œ `queryCache`ì™€ ì—¬ëŸ¬ ë§¤ë‹ˆì €ëŠ” `queryClient`ì—ì„œ ê´€ë¦¬í•˜ëŠ” êµ¬ì¡°ì…ë‹ˆë‹¤. ì˜ˆì œì½”ë“œì™€ ì´ë¯¸ì§€ë¥¼ ë¹„êµí•˜ë©´ì„œ í™•ì¸í•´ë³´ì‹œë©´ ì¢‹ì„ê²ƒ ê°™ìŠµë‹ˆë‹¤.

ê° ê°ì²´ë³„ë¡œ ë‚´ë¶€ ì½”ë“œë¥¼ í™•ì¸í•´ë³´ë©´ì„œ í•˜ëŠ” ì—­í• ì„ ì¢€ë” ìì„¸íˆ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

### query

```typescript
export class Query extends Removable {
  queryKey: TQueryKey
  queryHash: string
  options!: QueryOptions
  state: QueryState

  #initialState: QueryState<TData, TError>
  #revertState?: QueryState<TData, TError>
  #cache: QueryCache
  #client: QueryClient
  #retryer?: Retryer<TData>
  observers: Array<QueryObserver<any, any, any, any, any>>
  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>
  #abortSignalConsumed: boolean

  constructor(config: QueryConfig) {
    super()

    this.#abortSignalConsumed = false
    this.#defaultOptions = config.defaultOptions
    this.setOptions(config.options)
    this.observers = []
    this.#client = config.client
    this.#cache = this.#client.getQueryCache()
    this.queryKey = config.queryKey
    this.queryHash = config.queryHash
    this.#initialState = getDefaultState(this.options)
    this.state = config.state ?? this.#initialState
    this.scheduleGc()
  }

  setData(
    newData: TData,
    options?: SetDataOptions & { manual: boolean },
  ): TData {
    const data = replaceData(this.state.data, newData, this.options)

    // Set data and mark it as cached
    this.#dispatch({
      data,
      type: 'success',
      dataUpdatedAt: options?.updatedAt,
      manual: options?.manual,
    })

    return data
  }

  #dispatch(action: Action<TData, TError>): void {
    const reducer = (
      state: QueryState<TData, TError>,
    ): QueryState<TData, TError> => {
      switch (action.type) {
        case 'failed':
          return {
            ...state,
            fetchFailureCount: action.failureCount,
            fetchFailureReason: action.error,
          }
        case 'pause':
          return {
            ...state,
            fetchStatus: 'paused',
          }
        case 'continue':
          return {
            ...state,
            fetchStatus: 'fetching',
          }
        case 'fetch':
          return {
            ...state,
            ...fetchState(state.data, this.options),
            fetchMeta: action.meta ?? null,
          }
        case 'success':
          return {
            ...state,
            data: action.data,
            dataUpdateCount: state.dataUpdateCount + 1,
            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
            error: null,
            isInvalidated: false,
            status: 'success',
            ...(!action.manual && {
              fetchStatus: 'idle',
              fetchFailureCount: 0,
              fetchFailureReason: null,
            }),
          }
        case 'error':
          const error = action.error

          if (isCancelledError(error) && error.revert && this.#revertState) {
            return { ...this.#revertState, fetchStatus: 'idle' }
          }

          return {
            ...state,
            error,
            errorUpdateCount: state.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: state.fetchFailureCount + 1,
            fetchFailureReason: error,
            fetchStatus: 'idle',
            status: 'error',
          }
        case 'invalidate':
          return {
            ...state,
            isInvalidated: true,
          }
        case 'setState':
          return {
            ...state,
            ...action.state,
          }
      }
    }

    // ìƒíƒœ ì—…ë°ì´íŠ¸
    this.state = reducer(this.state)

    // ì¿¼ë¦¬ì˜ ì—…ë°ì´íŠ¸ë¥¼ ì˜µì €ë²„ì™€ ìºì‹œì—ê²Œ ì „íŒŒ
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onQueryUpdate()
      })

      this.#cache.notify({ query: this, type: 'updated', action })
    })
  }
}
}
```

`query`ëŠ” `queryKey`ê¸°ë°˜ìœ¼ë¡œ ì‹ë³„ë˜ëŠ” ê°ì²´ë¡œ `queryFn`ì— ë“¤ì–´ì˜¤ëŠ” í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•œ ê²°ê³¼ì™€ ì´ì— ëŒ€í•œ ìƒíƒœë¥¼ ê°€ì§‘ë‹ˆë‹¤. ì•ì„œ ë§ì”€ë“œë ¸ë˜ê²ƒ ì²˜ëŸ¼ `query`ëŠ” ìì‹ ì„ êµ¬ë…í•˜ëŠ” `observers`ë¥¼ ê°€ì§€ê³  ìˆìœ¼ë¯€ë¡œ, `query`ì˜ ìƒíƒœê°€ ë³€í™”í•˜ë©´ `observer`ì—ê²Œ ì „íŒŒí•˜ê²Œë©ë‹ˆë‹¤.

`query` ìƒíƒœë¥¼ ë³€ê²½í•˜ê³ ì í• ë•ŒëŠ” `dispatch`ë©”ì„œë“œì— ì›í•˜ëŠ” actionê³¼ payloadë¥¼ ë„£ì–´ í˜¸ì¶œí•˜ë©´ `dispatch`ë©”ì„œë“œ ë¯¸ë¦¬ ì •ì˜ëœ `reducer`í•¨ìˆ˜ì— ì´ë¥¼ í†µê³¼ì‹œí‚¤ê³ , ìƒíƒœë¥¼ ë³€ê²½í•œë’¤ `observer`ì—ê²Œ í†µë³´í•©ë‹ˆë‹¤. `setData` ë©”ì„œë“œì™€ `#dispatch` ë©”ì„œë“œë¥¼ ì°¸ê³ í•´ë³´ì„¸ìš”.

### queryObserver

```typescript
export class QueryObserver<
  TQueryFnData = unknown,
  TError = DefaultError,
  TData = TQueryFnData,
  TQueryData = TQueryFnData,
  TQueryKey extends QueryKey = QueryKey,
> extends Subscribable<QueryObserverListener<TData, TError>> {
  #client: QueryClient
  #currentQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> = undefined!
  #currentQueryInitialState: QueryState<TQueryData, TError> = undefined!
  #currentResult: QueryObserverResult<TData, TError> = undefined!
  #currentResultState?: QueryState<TQueryData, TError>
  #currentResultOptions?: QueryObserverOptions<
    TQueryFnData,
    TError,
    TData,
    TQueryData,
    TQueryKey
  >
  #currentThenable: Thenable<TData>
  #selectError: TError | null
  #selectFn?: (data: TQueryData) => TData
  #selectResult?: TData
  // This property keeps track of the last query with defined data.
  // It will be used to pass the previous data and query to the placeholder function between renders.
  #lastQueryWithDefinedData?: Query<TQueryFnData, TError, TQueryData, TQueryKey>
  #staleTimeoutId?: ReturnType<typeof setTimeout>
  #refetchIntervalId?: ReturnType<typeof setInterval>
  #currentRefetchInterval?: number | false
  #trackedProps = new Set<keyof QueryObserverResult>()

  constructor(
    client: QueryClient,
    public options: QueryObserverOptions<
      TQueryFnData,
      TError,
      TData,
      TQueryData,
      TQueryKey
    >,
  ) {
    super()

    this.#client = client
    this.#selectError = null
    this.#currentThenable = pendingThenable()
    if (!this.options.experimental_prefetchInRender) {
      this.#currentThenable.reject(
        new Error('experimental_prefetchInRender feature flag is not enabled'),
      )
    }

    this.bindMethods()
    this.setOptions(options)
  }
```

`query`ì˜ ìƒíƒœë³€í™”ë¥¼ êµ¬ë…í•˜ê³  ì»´í¬ë„ŒíŠ¸ê°€ êµ¬ë…í•˜ëŠ” ê°ì²´ì…ë‹ˆë‹¤. `query`ì˜ ìƒíƒœê°€ ë³€í™”í•˜ë©´ `observer`ê°€ ë³€í™”ë˜ê³ , `observer`ë¥¼ êµ¬ë…í•˜ëŠ” ì»´í¬ë„ŒíŠ¸ê°€ ë¦¬ë Œë”ë§ë˜ì–´ ìƒíƒœê°€ ì»´í¬ë„ŒíŠ¸ì— ë°˜ì˜ë˜ê²Œ ë©ë‹ˆë‹¤.

ì´ ê°ì²´ë¥¼ ìƒì„±í•˜ëŠ” ê°€ì¥ ê°„ë‹¨í•œ ë°©ë²•ì€ ë°”ë¡œ `useQuery`ë¥¼ ì‚¬ìš©í•˜ëŠ”ê²ƒì…ë‹ˆë‹¤. `useQuery`ë¥¼ ì‚¬ìš©í•˜ë©´ ìë™ìœ¼ë¡œ `observer`ë¥¼ ìƒì„±í•˜ì—¬ ìš°ë¦¬ê°€ `queryKey`ë¡œ ëª…ì‹œí•œ `query`ë¥¼ êµ¬ë…í•˜ê²Œë©ë‹ˆë‹¤.

### queryCache

```typescript
export class QueryCache extends Subscribable<QueryCacheListener> {
  #queries: QueryStore

  constructor(public config: QueryCacheConfig = {}) {
    super()
    this.#queries = new Map<string, Query>()
  }
  // build, add, remove, find ë“±ë“±...
}
```

`queryCache`ì˜ ì—­í• ì€ `query`ë“¤ì„ ê´€ë¦¬í•˜ëŠ”ê²ƒì…ë‹ˆë‹¤. í˜„ì¬ ì¡´ì¬í•˜ëŠ” ì¿¼ë¦¬ë“¤ì˜ ì €ì¥ì†Œ ì—­í•  ë¿ë§Œ ì•„ë‹ˆë¼, ìƒì„±, ì œê±°, ì°¾ê¸° ë“±ì˜ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.

### queryClient

```typescript
export class QueryClient {
  #queryCache: QueryCache
  #mutationCache: MutationCache
  #defaultOptions: DefaultOptions
  #queryDefaults: Map<string, QueryDefaults>
  #mutationDefaults: Map<string, MutationDefaults>
  #mountCount: number
  #unsubscribeFocus?: () => void
  #unsubscribeOnline?: () => void

  constructor(config: QueryClientConfig = {}) {
    this.#queryCache = config.queryCache || new QueryCache()
    this.#mutationCache = config.mutationCache || new MutationCache()
    this.#defaultOptions = config.defaultOptions || {}
    this.#queryDefaults = new Map()
    this.#mutationDefaults = new Map()
    this.#mountCount = 0
  }

  mount(): void {
    this.#mountCount++
    if (this.#mountCount !== 1) return

    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {
      if (focused) {
        await this.resumePausedMutations()
        this.#queryCache.onFocus()
      }
    })

    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {
      if (online) {
        await this.resumePausedMutations()
        this.#queryCache.onOnline()
      }
    })
  }

  unmount(): void {
    this.#mountCount--
    if (this.#mountCount !== 0) return

    this.#unsubscribeFocus?.()
    this.#unsubscribeFocus = undefined

    this.#unsubscribeOnline?.()
    this.#unsubscribeOnline = undefined
    // invalidQuries, setData ë“±ë“±...
  }
```

`queryClient`ëŠ” react-queryì˜ ëª¨ë“ ê²ƒì„ ê´€ë¦¬í•˜ëŠ” ì£¼ì²´ì…ë‹ˆë‹¤. ë”°ë¼ì„œ ì—¬ëŸ¬ ë§¤ë‹ˆì €(`focusManager`, `onlineManager`)ë¥¼ êµ¬ë…í•˜ê³  `queryCache`ë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.

ë˜í•œ `invalidQuries`, `setData`ë“± ì‚¬ìš©ìê°€ ì¿¼ë¦¬ì— ì ìš©í•  ìˆ˜ ìˆëŠ” ë‹¤ì–‘í•œ ë©”ì„œë“œë“¤ì„ ê°€ì§€ê³  ìˆê¸°ë„ í•©ë‹ˆë‹¤.

## ë§ˆì¹˜ë©°

ì´ë²ˆ ì•„í‹°í´ì„ í†µí•´ ê³µí†µì ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤ ë° í•µì‹¬ í´ë˜ìŠ¤ì˜ ë™ì‘ì— ëŒ€í•´ ì´í•´í•˜ì…¨ì„ ê²ƒì…ë‹ˆë‹¤. ë‹¤ìŒ ì•„í‹°í´ì—ì„œëŠ” useQueryì˜ ë™ì‘ì„ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

## ì°¸ê³ ìë£Œ

[ì˜µì €ë²„ íŒ¨í„´](https://ko.wikipedia.org/wiki/%EC%98%B5%EC%84%9C%EB%B2%84_%ED%8C%A8%ED%84%B4)
